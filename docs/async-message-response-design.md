# Asynchronous Message and Response Design

This document outlines a robust design for handling asynchronous operations, notifications, and their corresponding test strategies within the `ahma_mcp` project. The design is inspired by the mature structure of the `async_cargo_mcp` project and aims to address the challenges of testing asynchronous behaviors, particularly the risk of dropped notifications during synchronous blocking calls.

## 1. Core Principles

- **Isolation of Asynchronous and Synchronous Logic:** The core services should be designed to handle long-running asynchronous tasks and quick synchronous tasks without one blocking the other. This implies a multi-threaded or asynchronous task-based architecture for the `mcp_service`.
- **Guaranteed Notification Delivery:** The system must guarantee that notifications generated by any tool, especially asynchronous ones, are delivered to the client. If the client is busy or temporarily unresponsive (e.g., blocked by a synchronous `await`), notifications must be queued.
- **Comprehensive Behavioral Testing:** The test suite must be able to reliably simulate and verify complex interaction scenarios, including race conditions and edge cases involving mixed synchronous and asynchronous calls.

## 2. Proposed Architecture

### 2.1. Notification Queuing

A dedicated, thread-safe queue should be implemented for all outgoing notifications.

- When a tool call generates a notification, it is pushed to this queue.
- A separate dispatcher task (or thread) is responsible for reading from this queue and sending the notification to the client.
- This decouples the notification generation from the client's ability to receive it, preventing dropped messages. If the client is blocked, notifications will simply accumulate in the queue.

### 2.2. Test Utility Overhaul

The current approach of setting up test environments is inconsistent. A centralized and powerful test utility module is required. The structure observed in `async_cargo_mcp` (`tests/common/`) is a good model.

- **`tests/common/test_project.rs`:** This existing file should be enhanced to provide a consistent way to create temporary, isolated project environments for tests.
- **`tests/common/test_utils.rs`:** A new file should be created to house a standardized `setup_test_environment` function. This function will be the single entry point for creating an `AhmaMcpService` instance, a mock I/O handler, and a temporary directory for a test. This will eliminate code duplication and ensure all tests are set up consistently.
- **`MockIo`:** The mock I/O handler needs to be robust, allowing tests to easily send requests and, more importantly, receive and assert on notifications and responses. It should include methods for waiting for specific messages with timeouts to prevent flaky tests.

## 3. Behavioral Testing Strategy

The test suite should be structured to clearly separate different types of tests, as seen in `async_cargo_mcp`.

### 3.1. Test Categories

- **`tests/async_tests/`:** A new directory to house all tests specifically targeting asynchronous behavior. This includes tests for:
  - Long-running tools.
  - Correctness of `wait` operations.
  - Notification delivery during concurrent operations.
  - Race conditions between multiple asynchronous calls.
- **`tests/sync_tests/`:** A directory for tests focusing on synchronous tool calls, ensuring they execute quickly and return results correctly.
- **`tests/integration_tests/`:** For tests that verify the interaction between different components of the system. The test for the bug we are currently fixing (`async_notification_delivery_test.rs`) is a perfect example of an integration test, as it involves the interplay of async and sync tools.

### 3.2. The "Wait and Verify" Pattern

Tests for asynchronous operations must not rely on fixed `sleep` durations. They should use a "wait and verify" pattern.

1.  **Trigger Action:** An asynchronous operation is started.
2.  **Wait for Condition:** The test then waits for a specific condition to be met. This could be the receipt of a particular notification, a change in an operation's state, or the creation of a file. This "wait" should have a timeout to prevent tests from hanging indefinitely.
3.  **Assert:** Once the condition is met (or the timeout is reached), the test asserts that the outcome is correct.

The `MockIo` utility should provide helper functions to facilitate this pattern, for example, `wait_for_notification(method_name, timeout)`.

## 4. Action Plan Summary

1.  **Refactor Test Utilities:**
    - Create `tests/common/test_utils.rs`.
    - Implement a shared `setup_test_environment` function within it, abstracting the logic from existing tests like `adapter_test.rs`.
    - Make this new utility module public in `tests/common/mod.rs`.
2.  **Implement Notification Queuing:**
    - Analyze `src/mcp_service.rs` and `src/callback_system.rs`.
    - Introduce a thread-safe queue for outgoing notifications.
3.  **Fix the Bug:**
    - Create the new test `tests/integration_tests/async_notification_delivery_test.rs`.
    - Use the new `setup_test_environment` utility.
    - Implement the test logic to reproduce the bug, using the "wait and verify" pattern.
    - Run the test and confirm it fails.
    - The introduction of the notification queue should fix the bug. Run the test again to confirm it passes.
4.  **Restructure Tests:**
    - Create the `tests/async_tests` and `tests/sync_tests` directories.
    - Move existing relevant tests into these new directories to improve organization.
    - Update `tests/mcp_integration_tests.rs` to correctly include the modules from the new directories.
