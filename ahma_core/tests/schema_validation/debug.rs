//! Debug test to output the actual JSON schemas generated by mcp_service
//! This helps us see exactly what VSCode is receiving
use ahma_core::test_utils as common;

use ahma_core::utils::logging::init_test_logging;
use common::test_client::new_client;
use serde_json::Value;
use std::fs;
use tempfile::tempdir;

/// This test dumps the actual schemas to files for debugging VSCode failures
#[tokio::test]
async fn test_dump_actual_schemas_for_debugging() -> anyhow::Result<()> {
    init_test_logging();
    // Create a test client with the real tool configurations
    let client = new_client(Some(".ahma")).await?;
    let tools = client.list_all_tools().await?;

    println!(
        "Dumping schemas for {} tools to debug VSCode issue",
        tools.len()
    );

    // Create debug output directory using tempdir to avoid side effects
    let temp_dir = tempdir()?;
    let debug_dir = temp_dir.path().join("debug_schemas");
    fs::create_dir_all(&debug_dir)?;

    // Dump all tool schemas
    for tool in &tools {
        let schema_json = serde_json::to_string_pretty(tool.input_schema.as_ref())?;
        let filename = debug_dir.join(format!("{}_schema.json", tool.name));

        fs::write(&filename, &schema_json)?;
        println!("Wrote schema for '{}' to {:?}", tool.name, filename);

        // Check for array parameters in this tool
        if let Some(properties) = tool.input_schema.get("properties")
            && let Some(props_obj) = properties.as_object()
        {
            for (param_name, param_schema) in props_obj {
                if let Some(param_obj) = param_schema.as_object()
                    && param_obj.get("type") == Some(&Value::String("array".to_string()))
                {
                    println!(
                        "  ðŸ” Tool '{}' has array parameter '{}': {}",
                        tool.name,
                        param_name,
                        serde_json::to_string(param_obj)?
                    );

                    if let Some(items) = param_obj.get("items") {
                        println!("    âœ… Items property: {}", serde_json::to_string(items)?);
                    } else {
                        println!("    âŒ MISSING items property!");
                    }
                }
            }
        }
    }

    // Focus specifically on consolidated cargo tool which now includes cargo-audit options
    let cargo_tool = match tools.iter().find(|tool| tool.name == "cargo") {
        Some(tool) => tool,
        None => {
            println!("Skipping cargo analysis: cargo tool not found (may be CI environment)");
            println!(
                "Available tools: {:?}",
                tools.iter().map(|t| &t.name).collect::<Vec<_>>()
            );
            client.cancel().await?;
            return Ok(());
        }
    };

    println!("\nðŸ” DETAILED ANALYSIS OF cargo TOOL:");
    println!("Tool name: {}", cargo_tool.name);
    println!("Tool description: {:?}", cargo_tool.description);

    let schema_json = serde_json::to_string_pretty(cargo_tool.input_schema.as_ref())?;
    println!("Complete schema:\n{}", schema_json);

    // Write the specific problematic schema to temporary directory
    let problematic_file = debug_dir.join("PROBLEMATIC_cargo_schema.json");
    fs::write(&problematic_file, &schema_json)?;

    client.cancel().await?;
    Ok(())
}

/// Test with release build specifically
#[tokio::test]
async fn test_release_build_schema_generation() -> anyhow::Result<()> {
    init_test_logging();
    println!("Testing schema generation with release build...");

    // This will help us compare debug vs release build schemas
    let client = new_client(Some(".ahma")).await?;
    let tools = client.list_all_tools().await?;

    let cargo_tool = match tools.iter().find(|tool| tool.name == "cargo") {
        Some(tool) => tool,
        None => {
            println!(
                "Skipping test: cargo tool not found in tools directory (may be CI environment)"
            );
            println!(
                "Available tools: {:?}",
                tools.iter().map(|t| &t.name).collect::<Vec<_>>()
            );
            client.cancel().await?;
            return Ok(());
        }
    };

    println!("Release build cargo schema:");
    let schema = cargo_tool.input_schema.as_ref();

    if let Some(properties) = schema.get("properties")
        && let Some(props_obj) = properties.as_object()
    {
        for (param_name, param_schema) in props_obj {
            if let Some(param_obj) = param_schema.as_object()
                && param_obj.get("type") == Some(&Value::String("array".to_string()))
            {
                println!(
                    "Array param '{}': {}",
                    param_name,
                    serde_json::to_string(param_obj)?
                );

                // This is the critical check
                assert!(
                    param_obj.contains_key("items"),
                    "CRITICAL: Array parameter '{}' missing items property in RELEASE build!",
                    param_name
                );
            }
        }
    }

    client.cancel().await?;
    Ok(())
}
